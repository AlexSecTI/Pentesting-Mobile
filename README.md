# Pentesting-Mobile

Category Description Tools APK files and Information Gathering

Getting APK files and gathering info

    Get the Application directly from the client
    Download the app from the play store and pull it using ADB(rooted android device/non-rooted devices).
    Search for the app on play store and download it
    adb shell pm list packages -f | grep app_name
    It will show the com.package_name
    Look manually from the list of packages
    adb shell pm path com.package_name.
    adb pull /data/app/com.package_name..apk
    Check for application ecosystem
    React Native Application
    com.facebook.com.react entry in the AndroidManifest.xml file
    Flutter Application
    io.flutter folder from decompiling the app
    flutter.embedding entry in the AndroidManifest.xml file
    Download it from
    APKpure
    apk-downloader
    apkmirror
    apk-dl
    androidappsapk
    - A tool to download apk directly from play store PlaystoreDownloader
    adb tools

Installing on the device

    Simple to install it from the play store.
    If have apk on host system use
    “adb install application.apk”
    Note: Make sure and keep an eye on the Mobile device for the permission pop up while installing it.
    adb tools
    Emulator
    or
    Mobile device

Reverse engineering and Analysis

APk file analysis by reverse engineering

    APK package file contains the code of the application. (it is similar to zip file).it contains assets, res, lib, META-INF, AndroidManifest.xml, classes.dex(Dalvik binary bytecode)
    To see all these contents Convert .apk file to .zip file and extract(unzip) it.
    To read AndroidManifest.xml use Apktool
    Apktool d application.apk
    cd application
    Open AndroidManifest.XML in any text editor and analyze it.
    Reverse engineering DEX bytecode :
    Rename application.apk to application.zip and extract it.You will get classes.dex file
    Use d2j-dex2jar -f classes.dex file to get the java classes files.
    References to learn more
    AndroidAPPRE
    Android App Reverse Engineering LIVE!
    adb tools
    dex2jar
    JDGUI

Static Analysis (manually and automated)

    After getting the java source code, Analyze it and look for the sensitive information hardcoded into code like password, API keys
    Case Study: https://hackerone.com/reports/351555
    Use MobSF for Static Analysis to speed up the process
    MobSF
    adb tools
    apktool
    dex2jar
    JDGUI

Check App is Debuggable

    Android allows full-system backup which includes app data which are debuggable
    Attacker could take the backup of a debuggable app via adb
    Check android:debuggable attribute in AndroidManifest.xml file
    if the attribute value is true then its vulerable

-

Check for Typos in custom permission in Android manifest file

    Developers can use custom permission for android components to be used by autorized application only
    Typo in using custom permissions which don’t match declared custom permissions can be misused by unauthorized application
    Case Study: https://hackerone.com/reports/440749

—

Test for Exported Activity

    By default android activitiy is not exported but if an intent-filter is defined then it’s generally exported
    It is also possible that non exported activities could be executed by the exported activity, Check if you can control the execution of non exported activity via exported one using adb
    MobSF

Test for exported broadcast receiver

    Check for the exported broadcast receiver in the AndroidManifest.xml file
    Check if the attacker could send the payload to this exported broadcast receiver or the input is handled by the apk in any way
    MobSF

Network Analysis

Check for SSL pinning & its bypass

    Setup burp proxy(or another similar proxy) go to Http://burp
    Go to Settings > additional settings > privacy > certificates >install certificates from sd card (select the downloaded location) to install as a root CA certificate
    Capture the traffic of app
    If SSL certificate pinning is enabled you need to bypass it to capture and analyze the app traffic.
    Install Frida client on the host and run Frida server on a Mobile device(place the Frida server on a mobile device using:
    Test if Frida server is running properly using :
    Using objection to bypass sslpinning
    References to learn more
    SSL pinning/proxy setup
    Xposed-framework
    Frida
    Objection
    Burp Proxy
    Device/Emulator
    Xposed
    frida
    Objection

Dynamic Analysis

Analyzing App logs using pidcat tool

    shows log entries for processes from a specific application package
    pidcat target-app-package-name
    Pidcat
    Logcat

Check app UI is protected against a screenshot of sensitive information

    adb shell /system/bin/screencap /sdcard/img.png
    Here screen cap is the command-line utility to take screenshots of a device.
    Download it using adb pull /sdcard/img.png
    Read it using display img.png (on linux)

—

Check root detection mechanism is implemented

    Install the app on the rooted device if it is not showing any alert regarding the rooted device or not blocking the app to run. Then it is not protected with root detection.

—

Check shared preferences for persistent login

    For the first time for the login, the app asks for the user name and password and later it does not ask for the username and password.it stores the login key in login_account.xml at the shared preferences.it can be stolen by other app and attacker can use it

—

Checking for Keyboard cache

    Location /data/data/com.android.providers.userdictionary/databases/user_dict.db
    - Use SQLite to read it(user_dict.db)
    SQLite browser

Test for vulnerable Broadcast receivers

    Check for the intent which send by the broadcast (it can be a user input)
    and Check AndroidManifest file for broadcast receiver which has android exported=”true”(insecure way)
    - And develop the exploit according to the app functionality

–-

Test for Intent Sniffing

    Application could send broadcast intent without specifying the broadcast target
    Any malicious app could intercept these implicit broadcast
    Search sendBroadcast function in the decompiled code
    Case Study: https://hackerone.com/reports/56002

—

Test for Deep Linking Vulnerabilities

    Deep link are URLs which navigate users directly to the specific content in an applications
    To define deep links, intent filters are defined in AndroidManifest.xml file
    Intent filter must also include a category with the DEFAULT or BROWSABLE value
    Check for if scheme,host and parameters are validated properly

—

Test for WebView Vulnerabilities

    It allows to show web pages as an activity
    In smali code look for these strings
    @JavascriptInterface ,setJavaScriptEnabled ,setWebViewClient
    Check for dangerous WebView settings like setAllowFileAccess(true)

—

Test for local encryption issues

    Check for weak crypto alogs if used
    Vulnerable algo/outdated cipher: such as DES and 3DES,RC2,RC4, MD5 and SHA1,Dual_EC_DRBG and SHA1PRNG,BLOWFISH
    Inspect the app code to check used crypto algo instances
    Common configuration issues
    Check if symmetric encryption is used with hardcoded crypto keys.
    If app is using two way ssl ,check for the client SSL Certificate password locally (should not store it locally )

—

Finding Storage issues from android manifest file

Check for external storage by looking

    uses-permission : android:name="android.permission.WRITE_EXTERNAL_STORAGE"
    Check code for used file permission keywords/API to store data like : MODE_WORLD_READABLE or MODE_WORLD_WRITABLE (these two allow any app to read the file and write to this file)
    Check external storage for sensitive info stored (you can analyse the code to know more like above)

Look for classes and functions:

    SharedPreferences class (it stores key-value pairs)
    FileOutPutStream class (it uses internal or external storage),getExternal* function (use external storage)
    getReadableDatabase function (returns a SQLiteDatabase for reading)
    getCacheDir and getExternalCacheDirs(use cached files)
    Check for the bad practises used for encrypting the files
    getWritableDatabase function (returns a SQLiteDatabase for writing)

Check location for the secrets — res/values/strings.xml
- build configs like — local.properties, gradle.properties
- /data/misc/keystore/ —

Check for Input Validation issues

    For e.g. : login page ,try to login without using username and password (vai SQLinjection),keep checking the logs of the app you might see the SQli error
    Input validation check for URI schemes :
    Reading app files stored in sdcard or internal storage using “file:///path_of_file” schema to read the files
